'use strict';
var App, Request, Response, call, defer,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

Request = require('./request');

Response = require('./Response');

defer = setImmediate || function(fn) {
  return process.nextTick(fn.bind.apply(fn, arguments));
};

App = (function() {
  function App(opts) {
    if (opts == null) {
      opts = {};
    }
    this.handler = __bind(this.handler, this);
    this.handle = __bind(this.handle, this);
    this.use = __bind(this.use, this);
    this.last = __bind(this.last, this);
    this.set = __bind(this.set, this);
    this.get = __bind(this.get, this);
    this.route = "/";
    this.stack = [];
    this.cache = {};
    this.locals = {};
    this.settings = {
      "speech": "" + (process.cwd()) + "/speech",
      "format": "PlainText"
    };
  }


  /*
   * Returns the value of name app setting, where name is one of
   * strings in the app settings table.
   */

  App.prototype.get = function(name) {
    return this.settings[name];
  };


  /*
   * Sets the value of name app setting, where name is one of
   * strings in the app settings table.
   */

  App.prototype.set = function(name, value) {
    return this.settings[name] = value;
  };

  App.prototype.last = function(fn) {
    if (this.endApp == null) {
      this.endApp = new App();
    }
    return this.endApp.use(fn);
  };


  /*
   * Utilize the given middleware `handle` to the given `route`,
   * defaulting to _/_. This "route" is the mount-point for the
   * middleware, when given a value other than _/_ the middleware
   * is only effective when that segment is present in the request's
   * pathname.
   *
   * For example if we were to mount a function at _/admin_, it would
   * be invoked on _/admin_, and _/admin/settings_, however it would
   * not be invoked for _/_, or _/posts_.
   *
   * @param {String|Function|Server} route, callback or server
   * @param {Function|Server} callback or server
   * @return {Server} for chaining
   * @public
   */

  App.prototype.use = function() {
    var fn, h, handle, path, route, server, sub, _i, _len;
    route = arguments[0], fn = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    path = route;
    handle = fn;
    if (handle.length === 1) {
      handle = handle[0];
    }
    if (Array.isArray(handle)) {
      if (handle.length === 1) {
        handle = handle[0];
      } else {
        sub = new App;
        for (_i = 0, _len = handle.length; _i < _len; _i++) {
          h = handle[_i];
          sub.use(h);
        }
        handle = sub;
      }
    }
    if (typeof route !== 'string') {
      handle = route;
      path = '/';
    }
    if (typeof handle.handle === 'function') {
      server = handle;
      server.route = path;
      handle = function(req, res, next) {
        return server.handle(req, res, next);
      };
    }
    if (path[path.length - 1] === '/') {
      path = path.slice(0, -1);
    }
    this.stack.push({
      route: path,
      handle: handle
    });
    return this;
  };


  /*
   * Handle server requests, punting them down
   * the middleware stack.
   *
   * @private
   */

  App.prototype.handle = function(req, res, out) {
    var done, index, next, protohost, removed, slashAdded, stack;
    index = 0;
    protohost = '';
    removed = '';
    slashAdded = false;
    stack = this.stack;
    done = out;
    next = function(err) {
      var c, layer, path, route;
      if (slashAdded) {
        req.url = req.url.substr(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.url = protohost + removed + req.url.substr(protohost.length);
        removed = '';
      }
      layer = stack[index++];
      if (!layer) {
        return defer(done, err);
      }
      path = req.url || '/';
      route = layer.route;
      if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
        return next(err);
      }
      c = path[route.length];
      if (c !== void 0 && '/' !== c && '.' !== c) {
        return next(err);
      }
      if (route.length !== 0 && route !== '/') {
        removed = route;
        req.url = protohost + req.url.substr(protohost.length + removed.length);
        if (!protohost && req.url[0] !== '/') {
          req.url = '/' + req.url;
          slashAdded = true;
        }
      }
      return call(layer.handle, route, err, req, res, next);
    };
    req.originalUrl = req.originalUrl || req.url;
    return next();
  };


  /*
   * aws lambda handler
   *
   */

  App.prototype.handler = function(event, context, cb) {
    var out, req, res;
    if (arguments.length !== 3) {
      throw new Error("Old format not supported. Use with node 4.4");
    }
    req = Request.create({
      type: event.request.type,
      original: event,
      app: this
    });
    out = function(err) {
      if (err != null) {
        return cb(err);
      }
      return cb(null, res.data);
    };
    res = new Response({
      app: this,
      out: out
    });
    return this.handle(req, res, out);
  };

  return App;

})();


/**
 * Invoke a route handle.
 * @private
 */

call = function(handle, route, err, req, res, next) {
  var arity, e, error, hasError;
  arity = handle.length;
  error = err;
  hasError = Boolean(err);
  req.next = next;
  try {
    if (hasError && arity === 4) {
      return handle(err, req, res, next);
    }
    if (!hasError && arity < 4) {
      return handle(req, res, next);
    }
  } catch (_error) {
    e = _error;
    error = e;
  }
  return next(error);
};

module.exports = App;
